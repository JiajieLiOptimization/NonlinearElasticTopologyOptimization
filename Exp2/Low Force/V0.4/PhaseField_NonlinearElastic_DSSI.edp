macro el(x1,x2) [dx(x1),(dx(x2)+dy(x1)),dy(x2)]//
macro enl(x1,x2) [(dx(x1)*dx(x1)+dx(x2)*dx (x2))/2,(dx(x1)*dy(x1)+dx(x2)*dy(x2)),(dy(x1)*dy(x1)+dy(x2)*dy(x2))/2]//
macro denl(x1,x2,x3,x4) [(dx(x1)*dx(x3)+dx(x2)*dx(x4)),(dx(x1)*dy(x3)+dx(x2)*dy(x4)+dx(x3)*dy(x1)+dx(x4)*dy(x2)),(dy(x1)*dy(x3)+dy(x2)*dy(x4))]//
macro e(x1,x2) (el(x1,x2)+enl(x1,x2))//
macro de(x1,x2,x3,x4) (el(x3,x4)+denl(x1,x2,x3,x4))//
macro grad(u)[dx(u), dy(u)]//
//(el(uxa,uya) )'*D* (e(ux, uy))   //u1xR,u1yR,u2xR,u2yR,v1xR,v1yR,v2xR,v2yR
load "lapack"
real L=4;
real W=1;
real E1=3e9;
real E0=1e-9*E1;
real nu=0.4;
real fx=0;
real fy=-1.5e5;
real fxa=0;
real fya=fy;
real p=1;
real chg=1;
int s=1;
int i=0;
int Imax=100;
int loaded=1,free=2,fixed=3;
int PhaseIterNum = 10;

real dt = 0.0003;
real Sta1 = 1.0;
real Sta2 = 0.5;
real kappa = 1e-3;
real beta = 2000.0;
real lag = 0.0;
real eta = 30;
real t = 1.0;
real resold;
real a1, a2, a3, b1, b2, b3;
real triangleArea;
border bb1(t = 0.0, 1.0){x = t; y = 0.0; label = free;};
border bb2(t = 0.0, 0.33){x = 1.0; y = t; label = free;};
border bb3(t = 1.0, 1-0.05){x = t; y = 0.33; label = loaded;};
border bb4(t = 0.95, 0.33){x = t; y = 0.33; label = free;};
border bb5(t = 0.33, 1.0){x = 0.33; y = t; label = free;};
border bb6(t = 0.33, 0.0){x = t; y = 1.0; label = fixed;};
border bb7(t = 1.0, 0.0){x = 0.0; y = t; label = free;};
int n = 24;
mesh th = buildmesh (bb1(3*n)  + bb2(n)  + bb3(n/4)  + bb4(2*n)  +bb5(2*n)  + bb6(n) + bb7(3*n));

int nbvertices=th.nv;
int nbNeighbor = 10;
int nbtriangles = th.nt; 
int numTri;
int num = 100;
int kk = 0;

real[int, int] MapV2N(nbvertices, nbNeighbor);
MapV2N=-666;
for (int k=0;k<nbvertices;k++)
{
      numTri = 0;

      for (int i=0;i<nbtriangles;i++)
      {
        for (int j=0; j <3; j++)
          if (th(k)==th[i][j])
          {
            MapV2N(k,numTri) = i;
            numTri=numTri+1;
          }
      }

}

fespace Vh(th,  [P1,  P1]) ;
Vh [ux, uy],  [vx, vy],  [uxd, uyd],  [uxa,  uya], [vxa,  vya],  [uxn,  uyn];
fespace Vh1(th,  P1) ;
Vh1 E,theta,thetaold,thetanew,dtheta,sens,sensn,sensv,psi,r,u1xR,u1yR,u2xR,u2yR,v1xR,v1yR,v2xR,v2yR;
fespace Wh(th,  P0) ;
Wh gradu1x,gradu1y,gradu2x,gradu2y,gradv1x,gradv1y,gradv2x,gradv2y;

theta = 0.5;//1- ( 0.5*cos(pi*3*x+pi)*cos(pi*3*y)+0.5 );
E = theta^p*(E1 - E0) + E0;
real  lambda = nu/((1+nu)*(1-2*nu));
real mu = 1/(2*(1+nu));
real a11 = 2*mu + lambda,a12 = 0,a13=lambda ;
real a22= mu, a23 = 0;
real a33 = 2*mu + lambda;
func D=[[a11,a12,a13],[a12,a22,a23],[a13,a23,a33]];
real VolTarg = 0.4*int2d(th)(1);
real vol = int2d(th)(theta);
// Gradient recovery
real vu1p1, vu1p2, vu1p3, vu2p1, vu2p2, vu2p3, vvu1p1, vvu1p2, vvu1p3, vvu2p1, vvu2p2, vvu2p3;
real vdxu1, vdyu1, vdxu2, vdyu2, vdxv1, vdyv1, vdxv2, vdyv2;

plot(theta,fill =1,ps="ini.eps");

while (i<=Imax) {

  resold = 1e5;

   if (i==Imax-1 || i==2 || i==5 || i==15)
  {plot(theta,fill =1,ps="shape"+i+".eps");}

    i = i + 1; thetaold =theta;
    p = min(3., p+(i%5==0)*0.2);
    [ux, uy] = [0, 0];  
    [uxd, uyd] = [0, 0];
    for (int iner = 1;  iner <= 50;  iner ++){
           cout << "Nonlinear FEA inner loop"      <<
     iner << " starts..."<< endl;
          solve  nonlinear ([uxd,uyd],  [vx,vy])=int2d(th)(E*(de(ux, uy, uxd, uyd)'*D*de (ux, uy, vx, vy))+ (E*e(ux, uy)'*D*denl (vx, vy, uxd, uyd)))+int2d (th)(E*((e(ux, uy)'*D*de (ux, uy, vx,vy))))- int1d(th,  loaded)(fx*vx + fy*vy)+
         on(fixed, uxd = 0, uyd = 0);
               if(iner==1)  real ress = uxd[] .linfty;
                real res=uxd[].linfty;
                [ux,uy] =[ux + t*uxd, uy + t*uyd];
               cout  <<  "  .Linfty residual="<< res <<  endl;
               if (res > resold)
                t = 0.5*t;
                else
                t= 1.01*t;
              if (res<1e-3*ress)  break;
              resold = res;
    }
    [uxn, uyn] = [-ux,  -uy];
    solve nladjoint ([uxa,uya],  [vxa,vya])=int2d (th) (E* (de (uxn, uyn, uxa, uya)'*D*de (uxn, uyn, vxa, vya) )+ (E*e(uxn, uyn)'*D*denl(vxa, vya, uxa, uya))) -int1d(th,loaded) (fxa*vxa+fya*vya)+ on(fixed,  uxa=0 ,uya=0);
u1xR = dx(ux);u1yR = dy(ux);u2xR = dx(uy);u2yR = dy(uy);
v1xR = dx(uxa);v1yR = dy(uxa);v2xR = dx(uya);v2yR = dy(uya);
gradu1x=dx(ux);gradu1y=dy(ux);gradu2x=dx(uy);gradu2y=dy(uy);
gradv1x=dx(uxa);gradv1y=dy(uxa);gradv2x=dx(uya);gradv2y=dy(uya);
//对所有点做遍历
for (int k=0;k<nbvertices;k++)
{
  real value1 = 0,value2=0,value3=0,value4=0,value5=0,value6=0,value7=0,value8=0;
  int cc = 0;
  for (int s=0;s<nbNeighbor;s++)
  {
    if (MapV2N(k,s) > -1)
    {
      cc= cc+1;
    }
  }
  for (int p=0;p<cc;p++)
  {
    int q = MapV2N(k,p);
    vdxu1 = gradu1x[][q];
    vdyu1 = gradu1y[][q];
    vdxu2 = gradu2x[][q];
    vdyu2 = gradu2y[][q];
    vdxv1 = gradv1x[][q];
    vdyv1 = gradv1y[][q];
    vdxv2 = gradv2x[][q];
    vdyv2 = gradv2y[][q];
    value1 = value1+vdxu1;
    value2 = value2+vdyu1;
    value3 = value3+vdxu2;
    value4 = value4+vdyu2;
    value5 = value5+vdxv1;
    value6 = value6+vdyv1;
    value7 = value7+vdxv2;
    value8 = value8+vdyv2;
  }
  u1xR[][k]=value1/cc;
	u1yR[][k]=value2/cc;
	u2xR[][k]=value3/cc;
	u2yR[][k]=value4/cc;
  v1xR[][k]=value5/cc;
	v1yR[][k]=value6/cc;
	v2xR[][k]=value7/cc;
	v2yR[][k]=value8/cc;
}


  real norm = int2d(th)((-theta*(E1 - E0)*((el(uxa,uya) )'*D* (e(ux, uy))))^2); 
  real sqrtnorm = sqrt(norm);

  // updating r
  r = -eta/sqrtnorm*( -theta*(E1 - E0)*([v1xR, (v2xR+v1yR),v2yR]'*D*([u1xR, (u2xR+u1yR),u2yR]+ [(u1xR*u1xR+u2xR*u2xR)/2, u1xR*u1yR+u2xR*u2yR, (u1yR*u1yR+u2yR*u2yR)/2])    ) );

problem AllenCahn(theta,psi) = int2d(th)(theta*psi) - int2d(th)( thetaold*psi)
+ int2d(th)( dt*kappa*grad(theta)'*grad(psi))
+ int2d(th)(Sta1*dt*theta*psi)-int2d(th)(Sta1*dt*thetaold*psi) + int2d(th)(Sta2*dt*grad(theta)'*grad(psi))-int2d(th)(Sta2*dt*grad(thetaold)'*grad(psi)) 
+ int2d(th)(dt*beta*(vol-VolTarg)*psi+dt*lag*psi)
- int2d(th)(1/(0.1)*dt*thetaold*(1-thetaold)*(thetaold-0.5)*psi)
- int2d(th)(dt*r*psi);

  for(int k=0;k<PhaseIterNum;k++)
  {
     AllenCahn;
     thetaold =theta;
     thetaold = max(0,thetaold);
     thetaold = min(thetaold,1);
		 vol = int2d(th)(thetaold);
  }
     theta = max(0,theta);
     theta = min(theta,1);
     vol = int2d(th)(theta);
     lag = lag+1.0*(vol-VolTarg);
E = theta*(E1 - E0) + E0;

real J = int1d(th,  loaded) (fx*ux + fy*uy) ;
real   Wtotal = J + 0.5*beta*(vol-VolTarg)^2 + int2d(th)(0.5*kappa*grad(theta)'*grad(theta)+1/(kappa)*0.25*(theta-1)^2*theta^2);
ofstream obj("obj.txt",append);
obj<<J<<endl;
ofstream TotalEner("totalEnergy.txt",append);
TotalEner<<Wtotal<<endl;
ofstream Volerr("Volerr.txt",append);
Volerr<<abs(vol-VolTarg)<<endl;
string caption= " Objective: "+J +" total energy: "+Wtotal+" volume error: "+ (vol-VolTarg)+ " iter :"+i;
plot(theta,cmm=caption,fill =1,value=0);
//plot([ux,uy],cmm=caption,fill =1,value=1);
cout <<"iter ="  << i   <<";comp="<<J<<";vol =: "<<vol <<"___________"<<endl ;
}