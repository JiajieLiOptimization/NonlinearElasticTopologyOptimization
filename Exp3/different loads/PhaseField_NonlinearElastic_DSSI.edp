macro el(x1,x2) [dx(x1),(dx(x2)+dy(x1)),dy(x2)]//
macro enl(x1,x2) [(dx(x1)*dx(x1)+dx(x2)*dx (x2))/2,(dx(x1)*dy(x1)+dx(x2)*dy(x2)),(dy(x1)*dy(x1)+dy(x2)*dy(x2))/2]//
macro denl(x1,x2,x3,x4) [(dx(x1)*dx(x3)+dx(x2)*dx(x4)),(dx(x1)*dy(x3)+dx(x2)*dy(x4)+dx(x3)*dy(x1)+dx(x4)*dy(x2)),(dy(x1)*dy(x3)+dy(x2)*dy(x4))]//
macro e(x1,x2) (el(x1,x2)+enl(x1,x2))//
macro de(x1,x2,x3,x4) (el(x3,x4)+denl(x1,x2,x3,x4))//
macro grad(u)[dx(u), dy(u)]//
//(el(uxa,uya) )'*D* (e(ux, uy))   //u1xR,u1yR,u2xR,u2yR,v1xR,v1yR,v2xR,v2yR
load "lapack"
real L=4;
real W=1;
real E1=3e9;
real E0=1e-9*E1;
real nu=0.4;
real fx=0;
real fy=-1.5e4;
real fxa=0;
real fya=fy;
real p=1;
real chg=1;
int s=1;
int i=0;
int Imax=150;
int loaded=1,free=2,fixed=3;
int PhaseIterNum = 10;

real dt = 0.0005;
real Sta1 = 1.0;
real Sta2 = 0.1;
real kappa = 1e-3;
real beta = 500.0;
real lag = 0.0;
real eta = 30;
real t = 1.0;
real resold;
real a1, a2, a3, b1, b2, b3;
real triangleArea;

border bb1(t=-2.0,-0.05){x = t; y = -0.5; label = free;};
border bb2(t=-0.05,0.05){x = t; y = -0.5; label = loaded;};
border bb3(t=0.05, 2.0) {x = t; y = -0.5; label = free;};
border bb4(t=-0.5,-0.05){x = 2.0; y = t ; label = free;};
border bb5(t=-0.05,0.05){x = 2.0; y = t ; label = fixed;};
border bb6(t=0.05,0.5)  {x = 2.0; y = t ; label = free;};
border bb7(t=2.0,-2.0)  {x = t; y = 0.5; label = free;};
border bb8(t=0.5,0.05)  {x = -2.0; y = t ; label = free;};
border bb9(t=0.05,-0.05){x = -2.0; y = t ; label = fixed;};
border bb10(t=-0.05,-0.5){x = -2.0; y = t ; label = free;};
border inner1(t=2,0){x=0.15*cos(pi*t)-0.8;y=0.15*sin(pi*t);label=free;};
border inner2(t=2,0){x=0.15*cos(pi*t)+0.8;y=0.15*sin(pi*t);label=free;};
int nn = 5;
mesh th = buildmesh(bb1(19*nn)+bb2(nn)+bb3(19*nn)+bb4(4*nn)+bb5(nn)+bb6(4*nn)+bb7(40*nn)+bb8(4*nn)+bb9(nn)+bb10(4*nn) + inner1(12*nn) + inner2(12*nn));
fespace Vh(th,  [P1,  P1]) ;
Vh [ux, uy],  [vx, vy],  [uxd, uyd],  [uxa,  uya], [vxa,  vya],  [uxn,  uyn];
fespace Vh1(th,  P1) ;
Vh1 E,theta,thetaold,thetanew,dtheta,sens,sensn,sensv,psi,r;
theta =0.5;//1- ( 0.5*cos(pi*3*x+pi)*cos(pi*3*y)+0.5 );
E = theta^p*(E1 - E0) + E0;
real  lambda = nu/((1+nu)*(1-2*nu));
real mu = 1/(2*(1+nu));
real a11 = 2*mu + lambda,a12 = 0,a13=lambda ;
real a22= mu, a23 = 0;
real a33 = 2*mu + lambda;
func D=[[a11,a12,a13],[a12,a22,a23],[a13,a23,a33]];
real VolTarg = 0.5*int2d(th)(1);
real vol = int2d(th)(theta);


plot(theta,fill =1,ps="ini.eps");
while (chg > 1e-3 && i<=Imax) {
  t=1.0;
  resold = 1e5;

  if (i==2 || i==10)
  {
    plot(theta, value=1,ps="Contour"+i+"phase.eps");
  }
  if (i==30 || i== Imax-1)
  {
    plot(theta, fill=1, value=1,ps="filling"+i+"phase.eps");
  }

    i = i + 1; thetaold =theta;
    p = min(3., p+(i%5==0)*0.2);
    [ux, uy] = [0, 0];  
    [uxd, uyd] = [0, 0];
    for (int iner = 1;  iner <= 50;  iner ++){
           cout << "Nonlinear FEA inner loop"      <<
     iner << " starts..."<< endl;
          solve  nonlinear ([uxd,uyd],  [vx,vy])=int2d(th)(E*(de(ux, uy, uxd, uyd)'*D*de (ux, uy, vx, vy))+ (E*e(ux, uy)'*D*denl (vx, vy, uxd, uyd)))+int2d (th)(E*((e(ux, uy)'*D*de (ux, uy, vx,vy))))- int1d(th,  loaded)(fx*vx + fy*vy)+
         on(fixed, uxd = 0, uyd = 0);
               if(iner==1)  real ress = uxd[] .linfty;
                real res=uxd[].linfty+uyd[].linfty;
                [ux,uy] =[ux + t*uxd, uy + t*uyd];
               cout  <<  "  .Linfty residual="<< res <<  endl;
               if (res > resold)
                t = 0.5*t;
                else
                t= 1.01*t;
              if (res<1e-7)  break;
    }
    [uxn, uyn] = [-ux,  -uy];
    solve nladjoint ([uxa,uya],  [vxa,vya])=int2d (th) (E* (de (uxn, uyn, uxa, uya)'*D*de (uxn, uyn, vxa, vya) )+ (E*e(uxn, uyn)'*D*denl(vxa, vya, uxa, uya))) -int1d(th,loaded) (fxa*vxa+fya*vya)+ on(fixed,  uxa=0 ,uya=0);
    
  real norm = int2d(th)((-theta*(E1 - E0)*((el(uxa,uya) )'*D* (e(ux, uy))))^2); 
  real sqrtnorm = sqrt(norm);

  // updating r
  r = -eta/sqrtnorm*( -theta*(E1 - E0)*((el(uxa,uya) )'*D* (e(ux, uy))) );

problem AllenCahn(theta,psi) = int2d(th)(theta*psi) - int2d(th)( thetaold*psi)
+ int2d(th)( dt*kappa*grad(theta)'*grad(psi))
+ int2d(th)(Sta1*dt*theta*psi)-int2d(th)(Sta1*dt*thetaold*psi) + int2d(th)(Sta2*dt*grad(theta)'*grad(psi))-int2d(th)(Sta2*dt*grad(thetaold)'*grad(psi)) 
+ int2d(th)(dt*beta*(vol-VolTarg)*psi+dt*lag*psi)
- int2d(th)(1/(0.1)*dt*thetaold*(1-thetaold)*(thetaold-0.5)*psi)
- int2d(th)(dt*r*psi);

  for(int k=0;k<PhaseIterNum;k++)
  {
     AllenCahn;
     thetaold = theta;
     thetaold = max(0,thetaold);
     thetaold = min(thetaold,1);
		 vol = int2d(th)(thetaold);
  }
     theta = max(0,theta);
     theta = min(theta,1);
     lag = lag+0.5*(vol-VolTarg);
E = theta*(E1 - E0) + E0;

real J = int1d(th,  loaded) (fx*ux + fy*uy) ;
real   Wtotal = J + 0.5*beta*(vol-VolTarg)^2 + int2d(th)(0.5*kappa*grad(theta)'*grad(theta)+1/(kappa)*0.25*(theta-1)^2*theta^2);
ofstream obj("obj.txt",append);
obj<<J<<endl;
ofstream TotalEner("totalEnergy.txt",append);
TotalEner<<Wtotal<<endl;
ofstream Volerr("Volerr.txt",append);
Volerr<<abs(vol-VolTarg)<<endl;
string caption= " Objective: "+J +" total energy: "+Wtotal+" volume error: "+ (vol-VolTarg)+ " iter :"+i;
plot(theta,cmm=caption,fill =1,value=0);
//plot([ux,uy],cmm=caption,fill =1,value=1);
cout <<"iter ="  << i   <<";comp="<<J<<";vol =: "<<vol <<"___________"<<endl ;
}
