macro el(x1,x2) [dx(x1),(dx(x2)+dy(x1)),dy(x2)]//
macro enl(x1,x2) [(dx(x1)*dx(x1)+dx(x2)*dx (x2))/2,(dx(x1)*dy(x1)+dx(x2)*dy(x2)),(dy(x1)*dy(x1)+dy(x2)*dy(x2))/2]//
macro denl(x1,x2,x3,x4) [(dx(x1)*dx(x3)+dx(x2)*dx(x4)),(dx(x1)*dy(x3)+dx(x2)*dy(x4)+dx(x3)*dy(x1)+dx(x4)*dy(x2)),(dy(x1)*dy(x3)+dy(x2)*dy(x4))]//
macro e(x1,x2) (el(x1,x2)+enl(x1,x2))//
macro de(x1,x2,x3,x4) (el(x3,x4)+denl(x1,x2,x3,x4))//
macro grad(u)[dx(u), dy(u)]//
//(el(uxa,uya) )'*D* (e(ux, uy))   //u1xR,u1yR,u2xR,u2yR,v1xR,v1yR,v2xR,v2yR
load "lapack"
real L=4;
real W=1;
real E1=3e9;
real E0=1e-9*E1;
real nu=0.4;
real fx=0;
real fy=-1.5e8;
real fxa=0;
real fya=fy;
real p=1;
real chg=1;
int s=1;
int i=0;
int Imax=250;
int loaded=1,free=2,fixed=3;
int PhaseIterNum = 10;

real dt = 0.001;
real Sta1 = 1.0;
real Sta2 = 0.001;
real kappa = 0.01;
real beta = 500.0;
real lag = 0.0;
real eta = 30;
real t = 1.0;
real resold;
real a1, a2, a3, b1, b2, b3;
real triangleArea;

border bb1(t=-2.0,-0.05){x = t; y = -0.5; label = free;};
border bb2(t=-0.05,0.05){x = t; y = -0.5; label = loaded;};
border bb3(t=0.05, 2.0) {x = t; y = -0.5; label = free;};
border bb4(t=-0.5,-0.05){x = 2.0; y = t ; label = free;};
border bb5(t=-0.05,0.05){x = 2.0; y = t ; label = fixed;};
border bb6(t=0.05,0.5)  {x = 2.0; y = t ; label = free;};
border bb7(t=2.0,-2.0)  {x = t; y = 0.5; label = free;};
border bb8(t=0.5,0.05)  {x = -2.0; y = t ; label = free;};
border bb9(t=0.05,-0.05){x = -2.0; y = t ; label = fixed;};
border bb10(t=-0.05,-0.5){x = -2.0; y = t ; label = free;};
border inner1(t=2,0){x=0.15*cos(pi*t)-0.8;y=0.15*sin(pi*t);label=free;};
border inner2(t=2,0){x=0.15*cos(pi*t)+0.8;y=0.15*sin(pi*t);label=free;};
int nn = 3;
mesh th = buildmesh(bb1(19*nn)+bb2(nn)+bb3(19*nn)+bb4(4*nn)+bb5(nn)+bb6(4*nn)+bb7(40*nn)+bb8(4*nn)+bb9(nn)+bb10(4*nn) + inner1(12*nn) + inner2(12*nn));

int nbvertices=th.nv;
int nbNeighbor = 10;
int nbtriangles = th.nt; 
int numTri;
int num = 100;
int kk = 0;

real[int, int] MapV2N(nbvertices, nbNeighbor);
MapV2N=-666;
for (int k=0;k<nbvertices;k++)
{
      numTri = 0;

      for (int i=0;i<nbtriangles;i++)
      {
        for (int j=0; j <3; j++)
          if (th(k)==th[i][j])
          {
            MapV2N(k,numTri) = i;
            numTri=numTri+1;
          }
      }

}

fespace Vh(th,  [P1,  P1]) ;
Vh [ux, uy],  [vx, vy],  [uxd, uyd],  [uxa,  uya], [vxa,  vya],  [uxn,  uyn];
fespace Vh1(th,  P1) ;
Vh1 E,theta,thetaold,thetanew,dtheta,sens,sensn,sensv,psi,r,u1xR,u1yR,u2xR,u2yR,v1xR,v1yR,v2xR,v2yR;
fespace Wh(th,  P0) ;
Wh gradu1x,gradu1y,gradu2x,gradu2y,gradv1x,gradv1y,gradv2x,gradv2y, u1xp0, u1yp0, u2xp0, u2yp0, v1xp0, v1yp0, v2xp0, v2yp0;
theta =0.5;//1- ( 0.5*cos(pi*3*x+pi)*cos(pi*3*y)+0.5 );
E = theta^p*(E1 - E0) + E0;
real  lambda = nu/((1+nu)*(1-2*nu));
real mu = 1/(2*(1+nu));
real a11 = 2*mu + lambda,a12 = 0,a13=lambda ;
real a22= mu, a23 = 0;
real a33 = 2*mu + lambda;
func D=[[a11,a12,a13],[a12,a22,a23],[a13,a23,a33]];
real VolTarg = 0.5*int2d(th)(1);
real vol = int2d(th)(theta);

// Gradient recovery
real vu1p1, vu1p2, vu1p3, vu2p1, vu2p2, vu2p3, vvu1p1, vvu1p2, vvu1p3, vvu2p1, vvu2p2, vvu2p3;
real vdxu1, vdyu1, vdxu2, vdyu2, vdxv1, vdyv1, vdxv2, vdyv2;
plot(theta,fill =1,ps="ini.eps");
while (chg > 1e-3 && i<=Imax) {
  t=1.0;
  resold = 1e5;

  if (i==2 || i==10)
  {
    plot(theta, value=1,ps="Contour"+i+"phase.eps");
  }
  if (i==30 || i== Imax-1)
  {
    plot(theta, fill=1, value=1,ps="filling"+i+"phase.eps");
  }

    i = i + 1; thetaold =theta;
    p = min(3., p+(i%5==0)*0.2);
    [ux, uy] = [0, 0];  
    [uxd, uyd] = [0, 0];
    for (int iner = 1;  iner <= 5;  iner ++){
           cout << "Nonlinear FEA inner loop"      <<
     iner << " starts..."<< endl;
          solve  nonlinear ([uxd,uyd],  [vx,vy])=int2d(th)(E*(de(ux, uy, uxd, uyd)'*D*de (ux, uy, vx, vy))+ (E*e(ux, uy)'*D*denl (vx, vy, uxd, uyd)))+int2d (th)(E*((e(ux, uy)'*D*de (ux, uy, vx,vy))))- int1d(th,  loaded)(fx*vx + fy*vy)+
         on(fixed, uxd = 0, uyd = 0);
               if(iner==1)  real ress = uxd[] .linfty;
                real res=uxd[].linfty+uyd[].linfty;
                [ux,uy] =[ux + t*uxd, uy + t*uyd];
               cout  <<  "  .Linfty residual="<< res <<  endl;
               if (res > resold)
                t = 0.5*t;
                else
                t= 1.01*t;
              if (res<1e-7)  break;
    }
    [uxn, uyn] = [-ux,  -uy];
    solve nladjoint ([uxa,uya],  [vxa,vya])=int2d (th) (E* (de (uxn, uyn, uxa, uya)'*D*de (uxn, uyn, vxa, vya) )+ (E*e(uxn, uyn)'*D*denl(vxa, vya, uxa, uya))) -int1d(th,loaded) (fxa*vxa+fya*vya)+ on(fixed,  uxa=0 ,uya=0);
    u1xR = dx(ux);u1yR = dy(ux);u2xR = dx(uy);u2yR = dy(uy);
v1xR = dx(uxa);v1yR = dy(uxa);v2xR = dx(uya);v2yR = dy(uya);
gradu1x=dx(ux);gradu1y=dy(ux);gradu2x=dx(uy);gradu2y=dy(uy);
gradv1x=dx(uxa);gradv1y=dy(uxa);gradv2x=dx(uya);gradv2y=dy(uya);
u1xp0 = dx(ux); u1yp0 = dy(ux); u2xp0 = dx(uy); u2yp0 = dy(uy);
v1xp0=dx(uxa);v1yp0=dy(uxa);v2xp0=dx(uya);v2yp0=dy(uya);
//对所有点做遍历
for (int k=0;k<nbvertices;k++)
{
  real value1 = 0,value2=0,value3=0,value4=0,value5=0,value6=0,value7=0,value8=0;
  int cc = 0;
  for (int s=0;s<nbNeighbor;s++)
  {
    if (MapV2N(k,s) > -1)
    {
      cc= cc+1;
    }
  }

      if (cc<3)
      {
        	real value1 = 0,value2=0,value3=0,value4=0;
	        int count = 0;
          //对所有网格三角形做遍历
          for (int t=0;t<cc;t++)
          {	//访问每个三角形的三个节点，并判断是否是第k个点的相邻点
            int i = MapV2N(k,t);
            for (int j=0; j < 3; j++)
              if (th(k)==th[i][j])
              {
                count+=1;
                triangleArea = th[i].area;
                a1 = th(th[i][0]).x;b1 = th(th[i][0]).y;a2 = th(th[i][1]).x;b2 = th(th[i][1]).y;a3 = th(th[i][2]).x;b3 = th(th[i][2]).y;
                vu1p1 = ux[][th[i][0]];vu1p2 = ux[][th[i][1]];vu1p3 = ux[][th[i][2]];vu2p1 = uy[][th[i][0]];vu2p2 = uy[][th[i][1]];vu2p3 = uy[][th[i][2]];
                vdxu1 = 1/(2*triangleArea)*((b2-b3)*(vu1p1-vu1p3)+(b3-b1)*(vu1p2-vu1p3));
                vdyu1 = 1/(2*triangleArea)*((a3-a2)*(vu1p1-vu1p3)+(a1-a3)*(vu1p2-vu1p3));
                vdxu2 = 1/(2*triangleArea)*((b2-b3)*(vu2p1-vu2p3)+(b3-b1)*(vu2p2-vu2p3));
                vdyu2 = 1/(2*triangleArea)*((a3-a2)*(vu2p1-vu2p3)+(a1-a3)*(vu2p2-vu2p3));
                value1 = value1+vdxu1;
                value2 = value2+vdyu1;
                value3 = value3+vdxu2;
                value4 = value4+vdyu2;
              }
          }
          u1xR[][k]=value1/count;
          u1yR[][k]=value2/count;
          u2xR[][k]=value3/count;
          u2yR[][k]=value4/count;
        continue;
      }
      
      real [int,int] Ak(cc,3);real [int,int] AkT(3,cc);
      real [int] Bkux(cc);real [int] Bkuy(cc);
      real [int] Bkpx(cc);real [int] Bkpy(cc);
      real [int] ATbux(3);real [int] ATbuy(3);
      real [int] ATbpx(3);real [int] ATbpy(3);
      real [int,int] ATA(3,3);real [int,int] invATA(3,3);
      real [int] coffux(3);real [int] coffuy(3);
      real [int] coffpx(3);real [int] coffpy(3);
      real hk;


      for (int t=0; t<cc ;t++)
      {
        int TriLabel;
        real kx,ky;
        TriLabel = MapV2N(k,t);

        kx = (th(th[TriLabel][0]).x+th(th[TriLabel][1]).x+th(th[TriLabel][2]).x)/3;
        ky = (th(th[TriLabel][0]).y+th(th[TriLabel][1]).y+th(th[TriLabel][2]).y)/3;
        hk = max(hk,abs(kx-th(k).x),abs(ky-th(k).y));
      }

      for (int t=0; t<cc ;t++ )
      {
        int TriLabel;
        real kx,ky;
        TriLabel = MapV2N(k,t);

        kx = (th(th[TriLabel][0]).x+th(th[TriLabel][1]).x+th(th[TriLabel][2]).x)/3;
        ky = (th(th[TriLabel][0]).y+th(th[TriLabel][1]).y+th(th[TriLabel][2]).y)/3;


        Ak(t,0)=1.0;Ak(t,1)=(kx-th(k).x)/hk;Ak(t,2)=(ky-th(k).y)/hk;

        Bkux(t)=u1xp0[][th[TriLabel]];Bkuy(t)=u1yp0[][th[TriLabel]];
        Bkpx(t)=u2xp0[][th[TriLabel]];Bkpy(t)=u2yp0[][th[TriLabel]];
      }

    AkT = Ak';
    ATA = AkT*Ak;
 
    invATA= ATA^-1;

    ATbux = AkT*Bkux;ATbuy = AkT*Bkuy;
    ATbpx = AkT*Bkpx;ATbpy = AkT*Bkpy;

    coffux = invATA*ATbux;coffuy = invATA*ATbuy;
    coffpx = invATA*ATbpx;coffpy = invATA*ATbpy;
 
    real uxRec;real uyRec;real pxRec;real pyRec;
    //cout<<"x:"<<Th.be(k)[0].x<<"y:"<<Th.be(k)[0].y<<endl;
    uxRec = coffux(0);
    uyRec = coffuy(0);
    pxRec = coffpx(0);
    pyRec = coffpy(0);
    u1xR[][k] = uxRec;u1yR[][k] = uyRec;
    u2xR[][k] = pxRec;u2yR[][k] = pyRec;

//----------------------------

      for (int t=0; t<cc ;t++)
      {
        int TriLabel;
        real kx,ky;
        TriLabel = MapV2N(k,t);

        kx = (th(th[TriLabel][0]).x+th(th[TriLabel][1]).x+th(th[TriLabel][2]).x)/3;
        ky = (th(th[TriLabel][0]).y+th(th[TriLabel][1]).y+th(th[TriLabel][2]).y)/3;
        hk = max(hk,abs(kx-th(k).x),abs(ky-th(k).y));
      }

      for (int t=0; t<cc ;t++ )
      {
        int TriLabel;
        real kx,ky;
        TriLabel = MapV2N(k,t);

        kx = (th(th[TriLabel][0]).x+th(th[TriLabel][1]).x+th(th[TriLabel][2]).x)/3;
        ky = (th(th[TriLabel][0]).y+th(th[TriLabel][1]).y+th(th[TriLabel][2]).y)/3;


        Ak(t,0)=1.0;Ak(t,1)=(kx-th(k).x)/hk;Ak(t,2)=(ky-th(k).y)/hk;

        Bkux(t)=v1xp0[][th[TriLabel]];Bkuy(t)=v1yp0[][th[TriLabel]];
        Bkpx(t)=v2xp0[][th[TriLabel]];Bkpy(t)=v2yp0[][th[TriLabel]];
      }

    AkT = Ak';
    ATA = AkT*Ak;
 
    invATA= ATA^-1;

    ATbux = AkT*Bkux;ATbuy = AkT*Bkuy;
    ATbpx = AkT*Bkpx;ATbpy = AkT*Bkpy;

    coffux = invATA*ATbux;coffuy = invATA*ATbuy;
    coffpx = invATA*ATbpx;coffpy = invATA*ATbpy;
 
    //cout<<"x:"<<Th.be(k)[0].x<<"y:"<<Th.be(k)[0].y<<endl;
    uxRec = coffux(0);
    uyRec = coffuy(0);
    pxRec = coffpx(0);
    pyRec = coffpy(0);
    v1xR[][k] = uxRec;v1yR[][k] = uyRec;
    v2xR[][k] = pxRec;v2yR[][k] = pyRec;
}


  real norm = int2d(th)((-theta*(E1 - E0)*([v1xR, (v2xR+v1yR),v2yR]'*D*([u1xR, (u2xR+u1yR),u2yR]+ [(u1xR*u1xR+u2xR*u2xR)/2, u1xR*u1yR+u2xR*u2yR, (u1yR*u1yR+u2yR*u2yR)/2])    ) )^2); 
  real sqrtnorm = sqrt(norm);

  // updating r
  r = -eta/sqrtnorm*( -theta*(E1 - E0)*([v1xR, (v2xR+v1yR),v2yR]'*D*([u1xR, (u2xR+u1yR),u2yR]+ [(u1xR*u1xR+u2xR*u2xR)/2, u1xR*u1yR+u2xR*u2yR, (u1yR*u1yR+u2yR*u2yR)/2])    ) );

problem AllenCahn(theta,psi) = int2d(th)(theta*psi) - int2d(th)( thetaold*psi)
+ int2d(th)( dt*kappa*grad(theta)'*grad(psi))
+ int2d(th)(Sta1*dt*theta*psi)-int2d(th)(Sta1*dt*thetaold*psi) + int2d(th)(Sta2*dt*grad(theta)'*grad(psi))-int2d(th)(Sta2*dt*grad(thetaold)'*grad(psi)) 
+ int2d(th)(dt*beta*(vol-VolTarg)*psi+dt*lag*psi)
- int2d(th)(1/(0.1)*dt*thetaold*(1-thetaold)*(thetaold-0.5)*psi)
- int2d(th)(dt*r*psi);

  for(int k=0;k<PhaseIterNum;k++)
  {
     AllenCahn;
     thetaold = theta;
     thetaold = max(0,thetaold);
     thetaold = min(thetaold,1);
		 vol = int2d(th)(thetaold);
  }
     theta = max(0,theta);
     theta = min(theta,1);
     lag = lag+0.5*(vol-VolTarg);
E = theta*(E1 - E0) + E0;

real J = int1d(th,  loaded) (fx*ux + fy*uy) ;
real   Wtotal = J + 0.5*beta*(vol-VolTarg)^2 + int2d(th)(0.5*kappa*grad(theta)'*grad(theta)+1/(kappa)*0.25*(theta-1)^2*theta^2);
ofstream obj("obj.txt",append);
obj<<J<<endl;
ofstream TotalEner("totalEnergy.txt",append);
TotalEner<<Wtotal<<endl;
ofstream Volerr("Volerr.txt",append);
Volerr<<abs(vol-VolTarg)<<endl;
string caption= " Objective: "+J +" total energy: "+Wtotal+" volume error: "+ (vol-VolTarg)+ " iter :"+i;
plot(theta,cmm=caption,fill =1,value=0);
//plot([ux,uy],cmm=caption,fill =1,value=1);
cout <<"iter ="  << i   <<";comp="<<J<<";vol =: "<<vol <<"___________"<<endl ;
}
